#!/usr/bin/env python3
from __future__ import annotations
import sys
from pathlib import Path
import re
from typing import Any, Dict, List
"""
Simple validator and index generator for docs/installation-troubleshooting entries.

Usage:
    python tools/generate_troubleshooting_index.py [--strict]

This script is intentionally dependency-free. It parses a simple YAML-like
frontmatter block delimited by "---" at the top of each markdown file and
extracts a small set of fields. It validates required fields and writes a
generated index at `docs/installation-troubleshooting/_generated_index.md`.

Required frontmatter fields: title, date, os, status

Optional fields handled: arch, tags, severity, reproducible, verified_on

Behavior:
    it can be run locally without breaking workflows.
    (suitable for CI when the team is ready to enforce metadata).
"""

import argparse
 
ROOT = Path(__file__).resolve().parents[1]
TROUBLE_DIR = ROOT / "docs" / "installation-troubleshooting"
OUTPATH = TROUBLE_DIR / "_generated_index.md"

REQUIRED = ["title", "date", "os", "status", "severity", "arch", "reproducible"]

# Files to ignore in the troubleshooting dir (index and per-OS landing pages)
SKIP_NAMES = {"index.md", "macos.md", "linux.md", "windows.md"}


def parse_frontmatter(text: str) -> dict[str, Any]:
    """Parse a minimal YAML-like frontmatter block and return a mapping.

    The parser is intentionally small and dependency-free. It supports:
    - simple key: value pairs
    - lists expressed as [a, b]
    - booleans and null/None
    """
    lines = text.splitlines()
    if not lines:
        return {}

    if lines[0].strip() != "---":
        return {}

    # locate the closing '---'
    try:
        end = lines[1:].index("---") + 1
    except ValueError:
        return {}

    fm_lines = lines[1:end]
    data: dict[str, Any] = {}

    for raw in fm_lines:
        line = raw.strip()
        if not line or line.startswith("#") or ":" not in line:
            continue
        k, v = (part.strip() for part in line.split(":", 1))

        # strip surrounding quotes if present
        if (v.startswith("\"") and v.endswith("\"")) or (v.startswith("'") and v.endswith("'")):
            v = v[1:-1]

        low = v.lower()
        if low in {"null", "none"}:
            data[k] = None
            continue

        # list like [a, b]
        if v.startswith("[") and v.endswith("]"):
            inner = v[1:-1].strip()
            if not inner:
                data[k] = []
            else:
                parts = [p.strip().strip('"').strip("'") for p in inner.split(",")]
                data[k] = parts
            continue

        if low in {"true", "false"}:
            data[k] = low == "true"
            continue

        data[k] = v

    return data


def read_frontmatter(path: Path) -> Dict[str, Any]:
    text = path.read_text(encoding="utf8")
    return parse_frontmatter(text)


def build_index(entries: List[Dict[str, Any]]) -> str:
    header = "# Generated Troubleshooting Index\n\n"
    header += "This file is generated by `tools/generate_troubleshooting_index.py`.\n\n"
    header += "| Title | OS | Arch | Date | Status | Severity | Reproducible | Verified | Tags | File |\n"
    header += "|---|---|---:|---:|---|---|---|---|---|---|\n"
    rows = []
    for e in entries:
        title = e.get("title", "")
        os = e.get("os", "")
        arch = e.get("arch", "") or ""
        date = e.get("date", "") or ""
        status = e.get("status", "") or ""
        severity = e.get("severity", "") or ""
        reproducible = e.get("reproducible", "")
        reproducible = str(reproducible) if reproducible is not None else ""
        verified = e.get("verified_on", "") or ""
        tags = e.get("tags")
        if isinstance(tags, list):
            tags = ", ".join(tags)
        tags = tags or ""
        path = e.get("__path__", "")
        rows.append(
            f"| {title} | {os} | {arch} | {date} | {status} | {severity} | {reproducible} | {verified} | {tags} | [{path}]({path}) |"
        )
    return header + '\n'.join(rows) + '\n'


def main(argv: list[str] | None = None) -> int:
    if not TROUBLE_DIR.exists():
        print(f"Troubleshooting directory not found: {TROUBLE_DIR}", file=sys.stderr)
        return 1
    parser = argparse.ArgumentParser(description="Generate troubleshooting index and validate frontmatter")
    parser.add_argument("--strict", action="store_true", help="Exit non-zero if any file is missing required frontmatter fields")
    args = parser.parse_args(argv)

    md_files = sorted([
        p for p in TROUBLE_DIR.glob('*.md')
        if p.name != OUTPATH.name and not p.name.startswith('_') and p.name not in SKIP_NAMES
    ])
    entries: List[Dict[str, Any]] = []
    failed = False
    for p in md_files:
        data = read_frontmatter(p)
        if not data:
            print(f"WARN: no frontmatter found in {p.name}")
            # still include with minimal info
            data = {'title': p.stem, 'date': '', 'os': '', 'status': 'unknown'}
        data['__path__'] = p.name
        missing = [k for k in REQUIRED if k not in data or data.get(k) in (None, '')]
        if missing:
            print(f"ERROR: {p.name} missing required frontmatter fields: {missing}")
            failed = True
        entries.append(data)

    # Sort entries by os, then date
    def sort_key(e: Dict[str, Any]):
        return (e.get('os') or '', e.get('date') or '')

    entries.sort(key=sort_key)

    out = build_index(entries)
    OUTPATH.write_text(out, encoding='utf8')
    print(f"Wrote generated index to {OUTPATH}")
    if failed and args.strict:
        print("Validation failed (strict mode). Exiting non-zero.", file=sys.stderr)
        return 1
    # default: non-blocking so developers can run this locally without CI failures
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
